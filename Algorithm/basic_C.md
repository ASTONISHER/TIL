# 문자열, 문자
<h3>1. 문자열과 문자</h3>

```C
    char arr1[] = {'H', 'i', '!'};
    // 배열의 크기는 3
    
    char arr2[] = "Hi!";
    // 배열의 크기는 4, 마지막에 널문자 삽입되어있음
``` 
- 문자열은 끝을 확인하기 위해서 마지막에 널(\0)문자가 자동으로 삽입된다. 
- printf함수로 출력할 때에도 널 문자로 문자열을 구분해 냄.
- 널문자의 ASCII값은 0이므로 아래 두 코드는 같은 의미
```C
    str[1] = '\0';
    str[1] = 0;
```
- 문자열의 길이 계산 코드
```C
    while(arr[len] != '\0')
      len++;
```

# 포인터
<h3>1. 포인터</h3>

- 메모리 주소값을 저장하기 위해 생성
```C
    int main(){
        int num = 1;    
        int * p;        // 포인터 p 선언
        p = &num;       // num의 주소값을 p에 저장
    }
```
- 포인터 변수의 크기는 32비트에서 4비트, 64비트에서 8비트:
    주소값을 저장해야하기 때문에 주소 값의 길이만큼 할당
- 포인터 형은(int*, double*, float*) 그 크기가 모두 동일하다. (주소값이니까!)
- 포인터 사용 예1
```C
    int num = 10;
    int *p;
    
    p = &num;       // p에 num의 주소값을 저장
    (*p)++;         // p가 저장하고 있는 주소값에 있는 변수(num)을 1 증가시켜 num 은 11이 됨
```
- 포인터 사용 예2
```C
    int num = 10;
    int *p1 = &num;     // p1은 num을 가리킨다
    int *p2 = p1;       // p2는 p1을 가리키고, p1은 num을 가리키므로 **p2는 num을 가리킴**
    
    (*p2)++;            // num이 11이 됨
```

<h3>2. 포인터 연산</h3>

- 포인터 증감연산은 자료형의 크기만큼 증가/감소한다.
```C
    int *p1 = 0x0010;         // 임의로 주소값 넣어봄
    double *p2 = 0x0010;
    p1 + 3;                   // p1 = 0x0022가 됨
    p2++;                     // p2 = 0x0018이 됨
```
- 포인터와 배열 접근: __arr[i] == *(arr+i)__
```C
    int arr[] = {1, 3, 5};
    itn *p = arr;
    
    printf("%d %d %d\n", *p, *(p+1), *(p+2));   // 1, 3, 5 출력
    
    printf("%d ", *p);
    p++;
    printf("%d ", *p);
    p++;
    printf("%d \n", *p);                        // 1, 3, 5 출력
    // 포인터가 int형이므로 1 증가할 때마다 4씩 주소값이 옮겨져 결국 배열 인덱스와 같은 효과
```





