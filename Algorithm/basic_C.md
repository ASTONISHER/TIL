# 문자열, 문자
<h3>1. 문자열과 문자</h3>

```C
    char arr1[] = {'H', 'i', '!'};
    // 배열의 크기는 3
    
    char arr2[] = "Hi!";
    // 배열의 크기는 4, 마지막에 널문자 삽입되어있음
``` 
- 문자열은 끝을 확인하기 위해서 마지막에 널(\0)문자가 자동으로 삽입된다. 
- printf함수로 출력할 때에도 널 문자로 문자열을 구분해 냄.
- 널문자의 ASCII값은 0이므로 아래 두 코드는 같은 의미
```C
    str[1] = '\0';
    str[1] = 0;
```
- 문자열의 길이 계산 코드
```C
    while(arr[len] != '\0')
      len++;
```

# 포인터
<h3>1. 포인터</h3>

- 메모리 주소값을 저장하기 위해 생성
```C
    int main(){
        int num = 1;    
        int * p;        // 포인터 p 선언
        p = &num;       // num의 주소값을 p에 저장
    }
```
- 포인터 변수의 크기는 32비트에서 4비트, 64비트에서 8비트:
    주소값을 저장해야하기 때문에 주소 값의 길이만큼 할당
- 포인터 형은(int*, double*, float*) 그 크기가 모두 동일하다. (주소값이니까!)
- 포인터 사용 예1
```C
    int num = 10;
    int *p;
    
    p = &num;       // p에 num의 주소값을 저장
    (*p)++;         // p가 저장하고 있는 주소값에 있는 변수(num)을 1 증가시켜 num 은 11이 됨
```
- 포인터 사용 예2
```C
    int num = 10;
    int *p1 = &num;     // p1은 num을 가리킨다
    int *p2 = p1;       // p2는 p1을 가리키고, p1은 num을 가리키므로 **p2는 num을 가리킴**
    
    (*p2)++;            // num이 11이 됨
```

<h3>2. 포인터 연산</h3>

- 포인터 증감연산은 자료형의 크기만큼 증가/감소한다.
```C
    int *p1 = 0x0010;         // 임의로 주소값 넣어봄
    double *p2 = 0x0010;
    p1 + 3;                   // p1 = 0x0022가 됨
    p2++;                     // p2 = 0x0018이 됨
```
- 포인터와 배열 접근: __arr[i] == *(arr+i)__
```C
    int arr[] = {1, 3, 5};
    itn *p = arr;
    
    printf("%d %d %d\n", *p, *(p+1), *(p+2));   // 1, 3, 5 출력
    
    printf("%d ", *p);
    p++;
    printf("%d ", *p);
    p++;
    printf("%d \n", *p);                        // 1, 3, 5 출력
    // 포인터가 int형이므로 1 증가할 때마다 4씩 주소값이 옮겨져 결국 배열 인덱스와 같은 효과
```

<h3>3. 포인터 배열</h3>

- 주소값의 저장이 가능한 배열
```C
    int a=10, b=20, c=30;
    int *arr[3] = {&a, &b, &c};     // arr에 a, b, c의 주소값 저장
    
    printf("%d", *arr[1]);          // arr[1]에 저장된 주소값이 가리키는 변수에 저장된 값 출력 (20)
```
- 문자열 저장
```C
    char *arr[4] = {"Sinking", "Down", "with", "You"};
    printf("%s", arr[1]);       // Down 출력
    
    // 포인터 배열에 각 문자열의 주소값을 저장하기 때문에
    // arr[1]은 "Down\0"이 저장된 주소값으로 가서 거기 저장된 문자를 출력
    // \0문자가 나오면 정지해서 딱 Down만 출력됨
```

<h3>4. 포인터와 함수</h3>

- 인자 전달할 때에는 파라미터 자리를 int *para로 선언 해주고 호출시 그냥 부르면 됨
```C
    void example(int *param, int len){...}
    
    int main(){
        int arr[3] = {1, 2, 3};
        example(arr, sizeof(arr)/sizeof(int));
        return 0;
    }
```
- call-by-value: 인자로 단순히 변수 값을 전달 / call-by-reference: 인자로 변수의 주소값을 전달
```C
    void swap(int *num1, int *num2){        // num1, num2로 인자를 받으면 복사 형태로 인자전달이 되기 때문에 안됨 
        int temp = *num1;
        *num1 = *num2;
        *num2 = temp;
    }  
    
    // swap(&a, &b); 처럼 호출
```
- const: 코드의 안정성을 높이기 위해 
```C
    int num = 20;
    const int *ptr = &num;      
    
    // 포인터 변수를 이용해서 포인터가 가리키는 변수에 저장된 값을 변경하는 것을 허용하지 않음
        // *ptr = 30; 은 컴파일 에러를 발생시킴
        // 변수 자체를 상수화하는 것은 아니므로 num = 30; 은 정상작동
```

```C 
    int num1 = 10, num2 = 30;
    int *const ptr = &num1;
    
    // 포인터가 가리키는 주소값을 변경하지 못한다는 의미
        // *ptr = 50; 은 정상작동
        // ptr = &num2; 는 컴파일 에러
```


